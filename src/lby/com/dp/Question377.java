package lby.com.dp;
/*
* 377.组合总和4
*   给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
*   题目数据保证答案符合 32 位整数范围。请注意，顺序不同的序列被视作不同的组合(即排列)。
*   1 <= nums.length <= 200  1 <= nums[i] <= 1000
* 解:
*   思路1:动态规划 此题求的是排列数目！
*       1.确定dp数组元素及下标含义: dp[j]表示总和为j的排列数目
*       2.确定状态转移方程: dp[j]=d[j]+dp[j-nums[i]]
*       3.确定dp数组如何初始化: dp[0]=1(和为0只能是一个元素都不要)
*       4.确定dp数组遍历顺序: 由题目可知, nums元素可以重复使用, 且不同顺序视为不同结果, 所以可以得出是求排列的完全背包问题,
*           因此可以得出遍历顺序: dp在外层正序, nums在内层正序/倒序皆可
*
*       注: 背包问题中的组合与排列!!!
*           直白点, 若是求组合则物品数组在外层循环, dp数组在内层循环!
*                     求排列则dp数组在外层循环, 物品数组在内层循环!
*           原理: 物品(苹果, 橘子, 香蕉) dp背包
*                当物品在外, dp在内时, 物品的加入顺序就是固定的(取决于你的遍历方式,例如正序), 对于背包来说, 此时取出的是苹果,
*                   然后用每一种背包大小去尝试能否装入苹果, 所有可能尝试完了记录结果, 然后下一轮取出的一定且只能是橘子,
*                   因此只能找到(苹果, 香蕉)这样的排列, 而不会找到(香蕉, 苹果)的排列, 因此不可能找全一个组合的所有排序可能, 所以只有组合而无排序!
*                当物品在内, dp在外时, 对于内层循环, dp即背包大小是暂时固定的, 可以对每一个物品尝试放入, 此时依次尝试装入苹果 橘子 香蕉
*                   然后下一轮背包扩大了, 又可以从苹果开始尝试装入, 因此存在(苹果, 香蕉)这样的排列也存在(香蕉, 苹果)的排列, 所以可以找到所有组合!
* */
public class Question377 {
    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        System.out.println(combinationSum4(nums, 4));

    }
    public static int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        for (int j = 0; j < dp.length; j++) {
            for (int i = 0; i < nums.length; i++) {
                if (j >= nums[i])
                    dp[j] = dp[j] + dp[j-nums[i]];
            }
        }
        return dp[target];
    }
}
